
#include <iostream>
#include "Person.h"
#include "Student.h"
#include "Apple.h"
#include "Banana.h"
#include "GrannySmith.h"

void Task1()
{
    {
        Student s1("Jane", 18, Gender::Female, 168, 2022);
        s1.print();
    }
    //Student s1("Jane", 18, Gender::Female, 168, 2022);
    Student s2("Rob", 25, Gender::Male, 198, 2021);
    Student s3("Villy", 20, Gender::Others, 175, 2020);

    //s1.print();
    s2.print();
    s3.print();

    cout << "\n\n";
}

void Task2()
{
    Apple a("red");
    Banana b;
    GrannySmith c;

    std::cout << "My " << a.getName() << " is " << a.getColor() << ".\n";
    std::cout << "My " << b.getName() << " is " << b.getColor() << ".\n";
    std::cout << "My " << c.getName() << " is " << c.getColor() << ".\n";
    
    cout << "\n\n";
}

class A
{
public:
    int a;
};

class B : public A
{
public:
   B()
   {
       a = 1;
   }
};

void Task3()
{
    /// Создать перечисление CardType с типами трех карт:
    /// 1) Карта с цифрой (количество очков от 1 до 10) - NumericCard
    /// 2) Карта с картинкой (количество очков 10) - PictureCard
    /// 3) Карта туз (количество очков 1 или 11, по умолчанию 11) - AceCard
    
    /// Создать класс Card для любой карты в игре c полем типа CardType, с полем Score и методом GetScore.
    /// Можно было бы сделать через наследование, а не типизацию карт через enum CardType.
    
    /// Создать класс работы колодой карт CardDeck:
    /// 1) Создаем колоду карт CardDeck, в случайной последовательности складываем в стек экземпляры класса Card, учитывая информацию о количестве очков и количестве карт для каждого типа CardType. 
    /// 2) CardDeck имеет метод GetCard который вернет следующую карту из колоды.
    /// 
    /// Создать класс игрока Player
    /// 1) Player содержит поле со списком карт на руке, например vector
    /// 2) Player содержит функцию getSum(), которая будет подсчитывать сумму очков с руки игрока
    /// 3) Player содержит метод AddCard(Card& c), которая добавляет карту в руку.
    ///
    /// Создать класс игры BlackjackGame
    /// 1) BlackjackGame содержит список игроков, например vector
    /// 2) BlackjackGame содержит функцию GetNextPlayer(), которая возвращает следующего игрока, когда это необходимо. Функция учитывает количество игроков
    ///    которые остаются в игре (то есть не спасовали), и возвращает либо игрока либо пусто.
    /// 3) BlackjackGame содержит метод StopPlayer(Player& p), которая указывает на то что игрок более не участвует в игре (ему хватит карт, либо он набрал больше очков чем нужно)
    /// 3) BlackjackGame содержит метод GameLoop() для игрового цикла. 
    ///    Условие цикла получает следующего активного игрока. Если такого нет значит основная часть игры закончилась и пора подсчитывать очки и объявлять победителя.
    ///    Внутри цикла выполняется:
    ///    запрос действий игрока (нужна ему следующая карта или нет), и его обработка:
    ///    а) карта нужна - получение карты CardDeck::GetCard(), добавление карты игроку Player::AddCard, проверка суммы очков в руке игрока Player::GetSum(). 
    ///       Если сумма больше 21 то игрок прекращает игру вызовом метода BlackjackGame::StopPlayer. 
    ///    b) карта не нужна - пользователь хочет закончить набор карт поэтому вызываем метод BlackjackGame::StopPlayer
    
}

// внутри stack.h есть несколько вопросов, которые хочется понять / разобрать
int main()
{
    Task1();
    Task2();
    Task3();

    B b;
    A aa = (A)b;

    cout << aa.a;
}